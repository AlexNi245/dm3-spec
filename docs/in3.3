.\" Man page generated from reStructuredText.
.
.TH API REFERENCE CMD  "" "" ""
.SH NAME
API Reference CMD \- 
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Incubed can be used as a command\-line utility or as a tool in Bash scripts. This tool will execute a JSON\-RPC request and write the result to standard output.
.SH USAGE
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
in3 [options] method [arguments]
.ft P
.fi
.UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.BI \-c\fP,\fB  \-c\fB hain
The chain to use currently:
.INDENT 7.0
.TP
.B mainnet
Mainnet
.TP
.B kovan
Kovan testnet
.TP
.B tobalaba
EWF testchain
.TP
.B goerli
Goerli testchain using Clique
.TP
.B btc
Bitcoin (still experimental)
.TP
.B local
Use the local client on \fI\%http://localhost:8545\fP
.TP
.B RPCURL
If any other RPC\-URL is passed as chain name, this is used but without verification
.UNINDENT
.TP
.BI \-p\fP,\fB  \-p\fB roof
Specifies the verification level:
.INDENT 7.0
.TP
.B none
No proof
.TP
.B standard
Standard verification (default)
.TP
.B full
Full verification
.UNINDENT
.TP
.BI \-n\fB p
Short for \fB\-p none\fP\&.
.TP
.BI \-s\fP,\fB  \-s\fB igns
Number of signatures to use when verifying.
.TP
.BI \-b\fP,\fB  \-b\fB lock
The block number to use when making calls. Could be either \fBlatest\fP (default), \fBearliest\fP, or a hex number.
.TP
.BI \-p\fB k
The private key as raw keystore file.
.TP
.BI \-p\fB wd
Password to unlock the key.
.TP
.BI \-t\fB o
The target address of the call.
.TP
.BI \-s\fB t\fP,\fB \ \-s\fB igtype
the type of the signature data : \fBeth_sign\fP (use the prefix and hash it), \fBraw\fP (hash the raw data), \fBhash\fP (use the already hashed data). Default: raw
.TP
.BI \-p\fB ort
specifies the port to run incubed as a server. Opening port 8545 may replace a local parity or geth client.
.TP
.BI \-d\fP,\fB  \-d\fB ata
The data for a transaction.
.sp
This can be a file path, a 0x\-hexvalue, or \fB\-\fP to read it from standard input. If a method signature is given with the data, they will be combined and used as constructor arguments when deploying.
.TP
.BI \-g\fB as
The gas limit to use when sending transactions (default: 100000).
.TP
.BI \-v\fB alue
The value to send when conducting a transaction. Can be a hex value or a float/integer with the suffix \fBeth\fP or \fBwei\fP like \fB1.8eth\fP (default: 0).
.TP
.BI \-w\fP,\fB  \-w\fB ait
If given, \fBeth_sendTransaction\fP or \fBeth_sendRawTransaction\fP will not only return the transaction hash after sending but also wait until the transaction is mined and returned to the transaction receipt.
.TP
.BI \-j\fB son
If given, the result will be returned as JSON, which is especially important for \fBeth_call\fP, which results in complex structres.
.TP
.BI \-h\fB ex
If given, the result will be returned as hex.
.TP
.BI \-d\fB ebug
If given, Incubed will output debug information when executing.
.TP
.BI \-r\fB i
Reads the response from standard input instead of sending the request, allowing for offline use cases.
.TP
.BI \-r\fB o
Writes the raw response from the node to standard output.
.UNINDENT
.SH INSTALL
.SS From Binaries
.sp
You can download the binaries here:
.INDENT 0.0
.IP \(bu 2

.nf
:download:\(gamac os <downloads/osx/in3_osx>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(gawin64 <downloads/win/in3.exe>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(gaarmv7 <downloads/armv7/in3_armv7>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(gaarmv7hf <downloads/armv7hf/in3_armv7hf>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(galinux_x86 <downloads/x86/in3_x86>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(galinux_x64 <downloads/x64/in3_x64>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(gain3.jar <downloads/in3.jar>\(ga
.fi
\&.
.IP \(bu 2

.nf
:download:\(gainstaller <downloads/install.sh>\(ga
.fi
\&.
.UNINDENT
.sp
Or simply use this one\-liner:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
curl https://in3.readthedocs.io/en/develop/_downloads/install.sh \-sSf | sudo sh
.ft P
.fi
.UNINDENT
.UNINDENT
.SS From Sources
.sp
Before building, make sure you have these components installed:
.INDENT 0.0
.IP \(bu 2
CMake (should be installed as part of the build\-essential: \fBapt\-get install build\-essential\fP)
.IP \(bu 2
libcurl (for Ubuntu, use either \fBsudo apt\-get install libcurl4\-gnutls\-dev\fP or \fBapt\-get install libcurl4\-openssl\-dev\fP)
.IP \(bu 2
If libcurl cannot be found, Conan is used to fetch and build curl
.UNINDENT
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# clone the sources
git clone https://github.com/slockit/in3\-core.git

# create build\-folder
cd in3\-core
mkdir build && cd build
cmake \-DCMAKE_BUILD_TYPE=Release .. && make in3

# install
make install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
When building from source, CMake accepts the following flags:
.INDENT 0.0
.TP
.BI \-D\fB BUILD_DOC
If true, Doxygen is used to build the documentation (default: true).
.TP
.BI \-D\fB DEBUG
If set, additional DEBUG\-outputs are generated (default: false).
.TP
.BI \-D\fB EVM_GAS
If true, the gas costs are verified when validating an \fBeth_call\fP\&.
.UNINDENT
.sp
This is an optimization since most calls are only interested in the result. EVM_GAS would be required if the contract used gas\-dependent code.
.INDENT 0.0
.TP
.BI \-D\fB FAST_MATH
Enable math optimizations during \fBeth_call\fP (excutable size may increase) (default: false).
.TP
.BI \-D\fB TEST
Enable test output and memory leak management, but it slows down and should only be used for tests (default: false).
.TP
.BI \-D\fB WASM
If Wasm is enabled, only the Wasm module and its dependencies will be built (default: false).
.UNINDENT
.SS From Docker
.sp
Incubed can be run as docker container. For this pull the container:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# run a simple statement
docker run slockit/in3:latest eth_blockNumber

# to start it as a server
docker run \-p 8545:8545 slockit/in3:latest \-port 8545

# mount the cache in order to cache nodelists, validatorlists and contract code.
docker run \-v $(pwd)/cache:/root/.in3 \-p 8545:8545 slockit/in3:latest \-port 8545
.ft P
.fi
.UNINDENT
.UNINDENT
.SH ENVIRONMENT VARIABLES
.sp
The following environment variables may be used to define defaults:
.SH METHODS
.sp
As methods, the following can be used:
.SH RUNNING AS SERVER
.sp
While you can use \fBin3\fP to execute a request, return a result and quit, you can also start it as a server using the specified port ( \fB\-port 8545\fP ) to serve RPC\-requests.
Thiss way you can replace your local parity or geth with a incubed client. All Dapps can then connect to \fI\%http://localhost:8545\fP\&.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# starts a server at the standard port for kovan.
in3 \-c kovan \-port 8545
.ft P
.fi
.UNINDENT
.UNINDENT
.SH CACHE
.sp
Even though Incubed does not need a configuration or setup and runs completely statelessly, caching already verified data can boost the performance. That\(aqs why \fBin3\fP uses a cache to store.
.sp
By default, Incubed will use \fB~/.in3\fP as a folder to cache data.
.sp
If you run the docker container, you need to mount \fB/root/.in3\fP in to persist the cache.
.SH SIGNING
.sp
While Incubed itself uses an abstract definition for signing, at the moment, the command\-line utility only supports raw private keys.
There are two ways you can specify the private keys that Incubed should use to sign transactions:
.INDENT 0.0
.IP 1. 3
Use the environment variable \fBIN3_PK\fP\&.
This makes it easier to hide the key.
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
#!/bin/sh

IN3_PK = \(gacat my_private_key\(ga

in3 \-to 0x27a37a1210df14f7e058393d026e2fb53b7cf8c1 \-value 3\&.5eth \-wait send
in3 \-to 0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c  \-gas 1000000 \-pk 0x... send "registerServer(string,uint256)" "https://in3.slock.it/kovan1" 0xFF
.ft P
.fi
.UNINDENT
.UNINDENT
.IP 2. 3
Use the \fB\-pk\fP option
.INDENT 3.0
.INDENT 3.5
.sp
.nf
.ft C
in3 \-pk 27a37a1210df14f7e058393d27a37a1210df14f7e058393d026e2fb53b7cf8c1 \-to 0x27a37a1210df14f7e058393d026e2fb53b7cf8c1 \-value 200eth \-wait send
in3 \-pk \(gacat my_private_key\(ga \-to 0x27a37a1210df14f7e058393d026e2fb53b7cf8c1 \-value 200ETH \-wait send
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Usually, it is a bad idea to heavily privatize keys or to even use them as an option since this would mean they also appear in the Bash history. That\(aqs why the first approach is highly recommended. In the future, other signing approaches will be supported.
.SH AUTOCOMPLETION
.sp
If you want autocompletion, simply add these lines to your \fI\&.bashrc\fP or \fI\&.bash_profile\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
_IN3_WORDS=\(gain3 autocompletelist\(ga
complete \-W "$_IN3_WORDS" in3
.ft P
.fi
.UNINDENT
.UNINDENT
.SH FUNCTION SIGNATURES
.sp
When using \fBsend\fP or \fBcall\fP, the next optional parameter is the function signature. This signature describes not only the name of the function to call but also the types of arguments and return values.
.sp
In general, the signature is built by simply removing all names and only holding onto the types:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
<FUNCTION_NAME>(<ARGUMENT_TYPES>):(<RETURN_TYPES>)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
It is important to mention that the type names must always be the full Solidity names. Most Solidity functions use aliases. They would need to be replaced with the full type name.
.sp
e.g., \fBuint\fP \-> \fBuint256\fP
.SH EXAMPLES
.SS Getting the Current Block
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# On a command line:
in3 eth_blockNumber
> 8035324

# For a different chain:
in3 \-c kovan eth_blockNumber
> 11834906

# Getting it as hex:
in3 \-c kovan \-hex eth_blockNumber
> 0xb49625

# As part of shell script:
BLOCK_NUMBER=\(gain3 eth_blockNumber\(ga
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Using jq to Filter JSON
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Get the timestamp of the latest block:
in3 eth_getBlockByNumber latest false | jq \-r .timestamp
> 0x5d162a47

# Get the first transaction of the last block:
in3 eth_getBlockByNumber latest true | jq  \(aq.transactions[0]\(aq
> {
   "blockHash": "0xe4edd75bf43cd8e334ca756c4df1605d8056974e2575f5ea835038c6d724ab14",
   "blockNumber": "0x7ac96d",
   "chainId": "0x1",
   "condition": null,
   "creates": null,
   "from": "0x91fdebe2e1b68da999cb7d634fe693359659d967",
   "gas": "0x5208",
   "gasPrice": "0xba43b7400",
   "hash": "0x4b0fe62b30780d089a3318f0e5e71f2b905d62111a4effe48992fcfda36b197f",
   "input": "0x",
   "nonce": "0x8b7",
   "publicKey": "0x17f6413717c12dab2f0d4f4a033b77b4252204bfe4ae229a608ed724292d7172a19758e84110a2a926842457c351f8035ce7f6ac1c22ba1b6689fdd7c8eb2a5d",
   "r": "0x1d04ee9e31727824a19a4fcd0c29c0ba5dd74a2f25c701bd5fdabbf5542c014c",
   "raw": "0xf86e8208b7850ba43b7400825208947fb38d6a092bbdd476e80f00800b03c3f1b2d332883aefa89df48ed4008026a01d04ee9e31727824a19a4fcd0c29c0ba5dd74a2f25c701bd5fdabbf5542c014ca043f8df6c171e51bf05036c8fe8d978e182316785d0aace8ecc56d2add157a635",
   "s": "0x43f8df6c171e51bf05036c8fe8d978e182316785d0aace8ecc56d2add157a635",
   "standardV": "0x1",
   "to": "0x7fb38d6a092bbdd476e80f00800b03c3f1b2d332",
   "transactionIndex": "0x0",
   "v": "0x26",
   "value": "0x3aefa89df48ed400"
  }
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Calling a Function of a Smart Contract
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
 # Without arguments:
 in3 \-to 0x2736D225f85740f42D17987100dc8d58e9e16252 call "totalServers():uint256"
 > 5

 # With arguments returning an array of values:
 in3 \-to 0x2736D225f85740f42D17987100dc8d58e9e16252 call "servers(uint256):(string,address,uint256,uint256,uint256,address)" 1
 > https://in3.slock.it/mainnet/nd\-1
 > 0x784bfa9eb182c3a02dbeb5285e3dba92d717e07a
 > 65535
 > 65535
 > 0
 > 0x0000000000000000000000000000000000000000

# With arguments returning an array of values as JSON:
 in3 \-to 0x2736D225f85740f42D17987100dc8d58e9e16252 \-json call "servers(uint256):(string,address,uint256,uint256,uint256,address)" 1
 > ["https://in3.slock.it/mainnet/nd\-4","0xbc0ea09c1651a3d5d40bacb4356fb59159a99564","0xffff","0xffff","0x00","0x0000000000000000000000000000000000000000"]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Sending a Transaction
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
IN3_PK=\(gacat my_private_key\(ga

# Sends a transaction to a register server function and signs it with the private key given (\-pk 0x...):
in3 \-to 0x27a37a1210df14f7e058393d026e2fb53b7cf8c1  \-gas 1000000  send "registerServer(string,uint256)" "https://in3.slock.it/kovan1" 0xFF
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Deploying a Contract
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
# Compiling the Solidity code, filtering the binary, and sending it as a transaction returning the txhash:
solc \-\-bin ServerRegistry.sol | in3 \-gas 5000000 \-pk \(gacat my_private_key.txt\(ga \-d \- send

# If you want the address, you would need to wait until the text is mined before obtaining the receipt:
solc \-\-bin ServerRegistry.sol | in3 \-gas 5000000 \-pk \(gacat my_private_key.txt\(ga \-d \- \-wait send | jq \-r .contractAddress
.ft P
.fi
.UNINDENT
.UNINDENT
.\" Generated by docutils manpage writer.
.
